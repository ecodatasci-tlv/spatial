<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Working with spatial data in R</title>
    <meta charset="utf-8" />
    <meta name="date" content="2019-05-22" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/tabwid/tabwid.css" rel="stylesheet" />
    <script src="libs/tabwid/tabwid.js"></script>
    <link rel="stylesheet" href="custom-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Working with spatial data in R
## <a href="https://github.com/ecodatasci-tlv/spatial" class="uri">https://github.com/ecodatasci-tlv/spatial</a>
### 2019-05-22

---




# Topics we'll cover today:

* Types of spatial data
* Importing/Exporting spatial data
* Projections, extents, and units
* Comparison of different GIS tools out there
* Spatial data manipulation
* Intro to spatial analysis
* Visualizations (if we have time)

---
class: inverse, middle, center

#Data types



.small[
https://www.gislounge.com/geodatabases-explored-vector-and-raster-data/
]  
---
class: middle, center

# **Vector data**

Equivalent to a spreadsheet with a geometry column that describs how to plot the data that represents that feature

---
### **Polygons**
Two dimentional and are used for measurment of area and paramiters ofa geographical feature. 
.center[
.img-small[
![](pres_pictures/polygon-vector.png)
]]
---

### **Lines**
One dimentional and are used to only to measure length
.center[
.img-small[
![](pres_pictures/line-vector.png)
]]
---

### **Points**
Used to represent nonadjucent features 
.center[
.img-small[
![](pres_pictures/points-vector.png)
]]

---

# File type

* Polygon and lines come in a shapefile format, point usually are stored in XY table (a spreadsheet with latitude and longitude columns)

* A shapefile is structured from 4 main files: 
 - **shp** - the geometry of each feature
 - **dbf** - a dBase file with the attribute data for each feature (can be opened in excel; stores the metadata of each feature)
 - **prj** - The projection file
 - **shx** - a spatial index that helps a GIS program find the features in the .shp file quickly

**IMPORTANT:** each shapefile can only store one type of geometry - point/ polygon/ line
---
class: middle, center

# **Raster data**

Cell-based data, represents surfaces. Each cell represents a value
---

## **Two main types**

### **Continuous**
Example: temperature, elevation, etc.

### **Discrete**
Example: population density, species richenss, etc.

---

Rasters have three types of datasets: 

### **Thematic**
Used to represent discrete data, such as soil type or land use
.center[
.img-small[
![](pres_pictures/thematic_map.png)
]]
---
### **Spectral**
Aerial or setalite imagery
.center[
.img-med[
![](pres_pictures/mx.jpg)
]]
---
### **Surface**
Represents continuous changes across a landscape (for example elevation)
.center[
.img-med[
![](pres_pictures/gmted2010.png)
]]
---

class: center

# Vector and raster comparison
<div class="tabwid"><table style='border-collapse:collapse;'><thead><tr><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Data_type</span></p></td><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Pros</span></p></td><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Cons</span></p></td></tr></thead><tbody><tr><td rowspan="3" style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Vector</span></p></td><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">High geographical accuracy</span></p></td><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Doesn’t work well with continuous data</span></p></td></tr><tr><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Follows topology rules which increases integrity</span></p></td><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Processing intensive due to topology checks</span></p></td></tr><tr><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Used for measurements of proximity</span></p></td><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;"></span></p></td></tr><tr><td rowspan="3" style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Raster</span></p></td><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Very good for representing remote sensing data</span></p></td><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Less aesthetic pleasing</span></p></td></tr><tr><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Performs well with map algebra</span></p></td><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Lacks attribute data flexibility<br></span></p></td></tr><tr><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;"></span></p></td><td style="width:288px;height:18px;background-color:transparent;vertical-align: middle;transform: rotate(0deg);border-bottom: 1px solid rgba(51, 51, 51, 1.00);border-top: 1px solid rgba(51, 51, 51, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;"><p style="margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:2px;padding-top:2px;padding-left:5px;padding-right:5px;background-color:transparent;"><span style="font-family:'Arial';font-size:20px;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(17, 17, 17, 1.00);background-color:transparent;">Data size increases with the increase in resolution</span></p></td></tr></tbody></table></div>

---
class: center
# Importing Spatial Data
.center[
.img-med[
![](pres_pictures/dims.jpeg)
]]

---

Now that we've learned about different types of spatial data, let's load some. We'll use the rgdal package for this:


```r
pacman::p_load(rgdal)
pkmng_countries &lt;- readOGR(dsn = "Data",
                           layer = "pkmng_polygons")
```

```
## OGR data source with driver: ESRI Shapefile 
## Source: "/Users/marianovosolov/Dropbox/Studies/ecodatasci_tlv/spatial_analysis/Data", layer: "pkmng_polygons"
## with 246 features
## It has 12 fields
```

---

```r
head(pkmng_countries)
```

```
## class       : SpatialPolygonsDataFrame 
## features    : 6 
## extent      : -61.88722, 50.37499, -18.01639, 42.61805  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
## variables   : 12
## # A tibble: 6 x 12
##   FIPS  ISO2  ISO3     UN NAME    AREA POP2005 REGION SUBREGI    LON
##   &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;int&gt;   &lt;int&gt;  &lt;dbl&gt;
## 1 AC    AG    ATG      28 Anti~     44  8.30e4     19      29 -61.8 
## 2 AG    DZ    DZA      12 Alge~ 238174  3.29e7      2      15   2.63
## 3 AJ    AZ    AZE      31 Azer~   8260  8.35e6    142     145  47.4 
## 4 AL    AL    ALB       8 Alba~   2740  3.15e6    150      39  20.1 
## 5 AM    AM    ARM      51 Arme~   2820  3.02e6    142     145  44.6 
## 6 AO    AO    AGO      24 Ango~ 124670  1.61e7      2      17  17.5 
## # ... with 2 more variables: LAT &lt;dbl&gt;, pkmn_rc &lt;int&gt;
```

---
As usual, there is a tidyverse alternative to view spatial objects and edit the associated data
.small[

```r
pacman::p_load(spdplyr)
pkmng_countries
```

```
## class       : SpatialPolygonsDataFrame 
## features    : 246 
## extent      : -180, 180, -90, 83.57027  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
## variables   : 12
## # A tibble: 246 x 12
##    FIPS  ISO2  ISO3     UN NAME    AREA POP2005 REGION SUBREGI     LON
##    &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt;  &lt;int&gt;   &lt;dbl&gt;  &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt;
##  1 AC    AG    ATG      28 Anti…     44  8.30e4     19      29  -61.8 
##  2 AG    DZ    DZA      12 Alge… 238174  3.29e7      2      15    2.63
##  3 AJ    AZ    AZE      31 Azer…   8260  8.35e6    142     145   47.4 
##  4 AL    AL    ALB       8 Alba…   2740  3.15e6    150      39   20.1 
##  5 AM    AM    ARM      51 Arme…   2820  3.02e6    142     145   44.6 
##  6 AO    AO    AGO      24 Ango… 124670  1.61e7      2      17   17.5 
##  7 AQ    AS    ASM      16 Amer…     20  6.41e4      9      61 -171.  
##  8 AR    AR    ARG      32 Arge… 273669  3.87e7     19       5  -65.2 
##  9 AS    AU    AUS      36 Aust… 768230  2.03e7      9      53  136.  
## 10 BA    BH    BHR      48 Bahr…     71  7.25e5    142     145   50.6 
## # … with 236 more rows, and 2 more variables: LAT &lt;dbl&gt;,
## #   pkmn_rc &lt;int&gt;
```
]
---
With this package, you can use tidyverse functions to manipulate your spatial data:
.small[

```r
#filter out all countries without any Pokemon sightings, and let's rename the column while we're at it:
pkmng_countries %&gt;%
  filter(pkmn_rc &gt; 0) %&gt;%
  rename(Country = NAME)
```

```
## class       : SpatialPolygonsDataFrame 
## features    : 72 
## extent      : -179.999, 179.999, -55.9175, 83.10942  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
## variables   : 12
## # A tibble: 72 x 12
##    FIPS  ISO2  ISO3     UN Country   AREA POP2005 REGION SUBREGI
##    &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt;    &lt;int&gt;   &lt;dbl&gt;  &lt;int&gt;   &lt;int&gt;
##  1 AO    AO    AGO      24 Angola  124670  1.61e7      2      17
##  2 AR    AR    ARG      32 Argent~ 273669  3.87e7     19       5
##  3 AS    AU    AUS      36 Austra~ 768230  2.03e7      9      53
##  4 BK    BA    BIH      70 Bosnia~   5120  3.92e6    150      39
##  5 BM    MM    MMR     104 Burma    65755  4.80e7    142      35
##  6 BR    BR    BRA      76 Brazil  845942  1.87e8     19       5
##  7 BX    BN    BRN      96 Brunei~    527  3.74e5    142      35
##  8 CA    CA    CAN     124 Canada  909351  3.23e7     19      21
##  9 CB    KH    KHM     116 Cambod~  17652  1.40e7    142      35
## 10 CI    CL    CHL     152 Chile    74880  1.63e7     19       5
## # ... with 62 more rows, and 3 more variables: LON &lt;dbl&gt;, LAT &lt;dbl&gt;,
## #   pkmn_rc &lt;int&gt;
```
]
---
Now let's load our point data:
.small[

```r
pkmng_points_dat &lt;- read_csv("Data/pkmng_points.csv")
pkmng_points_dat
```

```
## # A tibble: 29,602 x 207
##    pokemonId latitude longitude appearedLocalTime   cellId_90m
##        &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;                   &lt;dbl&gt;
##  1        16     53.7    -0.443 2016-09-04 09:31:44    5.22e18
##  2        60     46.0     8.96  2016-09-06 07:57:06    5.15e18
##  3        19     46.2    15.3   2016-09-04 08:33:55    5.14e18
##  4        16     50.7    14.5   2016-09-04 09:23:24    5.12e18
##  5        23     44.5    11.3   2016-09-04 16:02:16    5.15e18
##  6       120     50.2    14.7   2016-09-03 15:51:17    5.12e18
##  7        46     33.6   -84.3   2016-09-07 01:05:11    9.87e18
##  8        10     46.0     8.95  2016-09-06 06:22:14    5.15e18
##  9        27     33.9  -118.    2016-09-06 05:13:44    9.28e18
## 10        23     34.3  -119.    2016-09-06 14:49:44    9.29e18
## # ... with 29,592 more rows, and 202 more variables:
## #   cellId_180m &lt;dbl&gt;, cellId_370m &lt;dbl&gt;, cellId_730m &lt;dbl&gt;,
## #   cellId_1460m &lt;dbl&gt;, cellId_2920m &lt;dbl&gt;, cellId_5850m &lt;dbl&gt;,
## #   appearedTimeOfDay &lt;chr&gt;, appearedHour &lt;dbl&gt;,
## #   appearedMinute &lt;dbl&gt;, appearedDayOfWeek &lt;chr&gt;, appearedDay &lt;dbl&gt;,
## #   appearedMonth &lt;dbl&gt;, appearedYear &lt;dbl&gt;, terrainType &lt;dbl&gt;,
## #   closeToWater &lt;lgl&gt;, city &lt;chr&gt;, continent &lt;chr&gt;, weather &lt;chr&gt;,
## #   temperature &lt;dbl&gt;, windSpeed &lt;dbl&gt;, windBearing &lt;dbl&gt;,
## #   pressure &lt;dbl&gt;, weatherIcon &lt;chr&gt;, sunriseMinutesMidnight &lt;dbl&gt;,
## #   sunriseHour &lt;dbl&gt;, sunriseMinute &lt;dbl&gt;,
## #   sunriseMinutesSince &lt;dbl&gt;, sunsetMinutesMidnight &lt;dbl&gt;,
## #   sunsetHour &lt;dbl&gt;, sunsetMinute &lt;dbl&gt;, sunsetMinutesBefore &lt;dbl&gt;,
## #   population_density &lt;dbl&gt;, urban &lt;lgl&gt;, suburban &lt;lgl&gt;,
## #   midurban &lt;lgl&gt;, rural &lt;lgl&gt;, gymDistanceKm &lt;dbl&gt;,
## #   gymIn100m &lt;lgl&gt;, gymIn250m &lt;lgl&gt;, gymIn500m &lt;lgl&gt;,
## #   gymIn1000m &lt;lgl&gt;, gymIn2500m &lt;lgl&gt;, gymIn5000m &lt;lgl&gt;,
## #   pokestopDistanceKm &lt;dbl&gt;, pokestopIn100m &lt;lgl&gt;,
## #   pokestopIn250m &lt;lgl&gt;, pokestopIn500m &lt;lgl&gt;,
## #   pokestopIn1000m &lt;lgl&gt;, pokestopIn2500m &lt;lgl&gt;,
## #   pokestopIn5000m &lt;lgl&gt;, cooc_1 &lt;lgl&gt;, cooc_2 &lt;lgl&gt;, cooc_3 &lt;lgl&gt;,
## #   cooc_4 &lt;lgl&gt;, cooc_5 &lt;lgl&gt;, cooc_6 &lt;lgl&gt;, cooc_7 &lt;lgl&gt;,
## #   cooc_8 &lt;lgl&gt;, cooc_9 &lt;lgl&gt;, cooc_10 &lt;lgl&gt;, cooc_11 &lt;lgl&gt;,
## #   cooc_12 &lt;lgl&gt;, cooc_13 &lt;lgl&gt;, cooc_14 &lt;lgl&gt;, cooc_15 &lt;lgl&gt;,
## #   cooc_16 &lt;lgl&gt;, cooc_17 &lt;lgl&gt;, cooc_18 &lt;lgl&gt;, cooc_19 &lt;lgl&gt;,
## #   cooc_20 &lt;lgl&gt;, cooc_21 &lt;lgl&gt;, cooc_22 &lt;lgl&gt;, cooc_23 &lt;lgl&gt;,
## #   cooc_24 &lt;lgl&gt;, cooc_25 &lt;lgl&gt;, cooc_26 &lt;lgl&gt;, cooc_27 &lt;lgl&gt;,
## #   cooc_28 &lt;lgl&gt;, cooc_29 &lt;lgl&gt;, cooc_30 &lt;lgl&gt;, cooc_31 &lt;lgl&gt;,
## #   cooc_32 &lt;lgl&gt;, cooc_33 &lt;lgl&gt;, cooc_34 &lt;lgl&gt;, cooc_35 &lt;lgl&gt;,
## #   cooc_36 &lt;lgl&gt;, cooc_37 &lt;lgl&gt;, cooc_38 &lt;lgl&gt;, cooc_39 &lt;lgl&gt;,
## #   cooc_40 &lt;lgl&gt;, cooc_41 &lt;lgl&gt;, cooc_42 &lt;lgl&gt;, cooc_43 &lt;lgl&gt;,
## #   cooc_44 &lt;lgl&gt;, cooc_45 &lt;lgl&gt;, cooc_46 &lt;lgl&gt;, cooc_47 &lt;lgl&gt;,
## #   cooc_48 &lt;lgl&gt;, cooc_49 &lt;lgl&gt;, cooc_50 &lt;lgl&gt;, ...
```
]
---
We are going to create a shapefile from this table.


```r
pacman::p_load(sp)
xy &lt;- tibble(longitude = pkmng_points_dat$longitude,
             latitude = pkmng_points_dat$latitude)
pkmng_points &lt;- SpatialPointsDataFrame(coords = xy,
                                      data = pkmng_points_dat)
pkmng_points
```

```
## class       : SpatialPointsDataFrame 
## features    : 29602 
## extent      : -158.0198, 175.6162, -42.9845, 68.43698  (xmin, xmax, ymin, ymax)
## coord. ref. : NA 
## variables   : 207
## names       : pokemonId,   latitude,   longitude,   appearedLocalTime,   cellId_90m,  cellId_180m,  cellId_370m,  cellId_730m, cellId_1460m, cellId_2920m, cellId_5850m, appearedTimeOfDay, appearedHour, appearedMinute, appearedDayOfWeek, ... 
## min values  :         1,   1.282526,    0.000046, 2016-09-02 21:50:11, 1.008879e+19, 1.008879e+19, 1.008879e+19, 1.008879e+19, 1.008879e+19, 1.008879e+19, 1.008879e+19,         afternoon,            0,              0,         dummy_day, ... 
## max values  :       149, -42.984504, -158.019758, 2016-09-08 03:51:27, 9.937698e+18, 9.937698e+18, 9.937698e+18, 9.937698e+18, 9.937698e+18, 9.937698e+18, 9.937698e+18,             night,           23,             59,         Wednesday, ...
```

---
# GeoJSON

So far we've been working with ESRI shapefiles. This is a format to encode geographic data, used widely in GIS systems.

Alternatively, there is the java-based GeoJSON format for encoding geographic data, which can support the features we've discussed (points, polygons).

There are advantages to GeoJSON, including reduced file sizes. Compare:

---

```r
pacman::p_load(geojsonio)
pacman::p_load(rmapshaper)

#we now convert our ESRI shapefile (a SpatialPoylgonsDataFrame object) to GeoJSON format:
pkmng_countries_json &lt;- geojson_json(pkmng_countries) #this can be VERY time-consuming
```

Compare the file sizes: 6.4 Mb for the ESRI format, compared to 1.1 Mb for the GeoJSON format!

Read more about GeoJSON here: https://macwright.org/2015/03/23/geojson-second-bite.html

---
# Rasters
Finally, importing rasters is easily done with the raster package:

```r
pacman::p_load(raster)
pkmng_raster &lt;- raster("Data/pkmng_raster.tif")

pkmng_raster
```

```
## class       : RasterLayer 
## dimensions  : 87, 180, 15660  (nrow, ncol, ncell)
## resolution  : 2, 2  (x, y)
## extent      : -180, 180, -90.42973, 83.57027  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
## data source : /Users/marianovosolov/Dropbox/Studies/ecodatasci_tlv/spatial_analysis/Data/pkmng_raster.tif 
## names       : pkmng_raster 
## values      : 0, 9.535896  (min, max)
```

---
# Projections
One of the most important things to remember when dealing with spatial data is the projection.

A projection is a mathematical transformation of coordinates from the surface of a sphere on a 2D plane.

.center[![](img/m-c.jpg)]

---
# Types of projections
## Projections by surface
Classification based on the type of surface onto which the globe is projected:
* Cylindrical
* Conic
* Azimuthal

etc.

---
## Projections by preservation of a metric property
Classification based on which property is maintained in the projection:
* Conformal (preserves shape, usually distorts area)
* Equal-area (preserves area, usually distorts shape)
* Equidistant (preserves distance from some point or line)

etc.

---
You can view the Coordinate Reference System of your spatial objects:

```r
crs(pkmng_countries)
```

```
## CRS arguments:
##  +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0
```

You can see different values here, including the datum, units, etc.

---
Notice our points shapefile has no projection, because we didn't set it when creating the object:

```r
crs(pkmng_points)
```

```
## CRS arguments: NA
```

---
We can set the projection for this object, either by writing a string of our desired projection, or extracting the projection from an existing object:

```r
proj1 &lt;- crs("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
proj1
```

```
## CRS arguments:
##  +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0
```

```r
proj2 &lt;- crs(pkmng_countries)
proj2
```

```
## CRS arguments:
##  +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0
```

---

```r
proj4string(pkmng_points) &lt;- proj1
pkmng_points
```

```
## class       : SpatialPointsDataFrame 
## features    : 29602 
## extent      : -158.0198, 175.6162, -42.9845, 68.43698  (xmin, xmax, ymin, ymax)
## crs         : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 
## variables   : 207
## names       : pokemonId,   latitude,   longitude, appearedLocalTime,           cellId_90m,          cellId_180m,          cellId_370m,         cellId_730m,         cellId_1460m,         cellId_2920m,         cellId_5850m, appearedTimeOfDay, appearedHour, appearedMinute, appearedDayOfWeek, ... 
## min values  :         1, -42.984504, -158.019758,        1472853011,    43172735374852096,    43172735576178688,    43172735307743232,   43172732086517760,    43172719201615872,    43172667662008320,    43172598942531584,         afternoon,            0,              0,         dummy_day, ... 
## max values  :       149,   68.43698,  175.616223,        1473306687, 12280882455157669888, 12280882455224778752, 12280882455493214208, 1.2280882456567e+19, 12280882443682054144, 12280882495221661696, 12280882701380091904,             night,           23,             59,         Wednesday, ...
```

---
You can also transform already existing objects to have different projections:


```r
pkmng_points_p &lt;- spTransform(pkmng_points,
                              crs("+proj=laea  +lat_0=0 +lon_0=0"))
pkmng_points_p
```

```
## class       : SpatialPointsDataFrame 
## features    : 29602 
## extent      : -9285067, 11178209, -11993372, 9520128  (xmin, xmax, ymin, ymax)
## crs         : +proj=laea +lat_0=0 +lon_0=0 +ellps=WGS84 
## variables   : 207
## names       : pokemonId,   latitude,   longitude, appearedLocalTime,           cellId_90m,          cellId_180m,          cellId_370m,         cellId_730m,         cellId_1460m,         cellId_2920m,         cellId_5850m, appearedTimeOfDay, appearedHour, appearedMinute, appearedDayOfWeek, ... 
## min values  :         1, -42.984504, -158.019758,        1472853011,    43172735374852096,    43172735576178688,    43172735307743232,   43172732086517760,    43172719201615872,    43172667662008320,    43172598942531584,         afternoon,            0,              0,         dummy_day, ... 
## max values  :       149,   68.43698,  175.616223,        1473306687, 12280882455157669888, 12280882455224778752, 12280882455493214208, 1.2280882456567e+19, 12280882443682054144, 12280882495221661696, 12280882701380091904,             night,           23,             59,         Wednesday, ...
```

---
Why are projections so important?

Here's our points mapped on top of a shapefile of countries:

```r
plot(countries, axes = T)
plot(pkmng_points, add = T, pch = 1, col = "red")
```

&lt;img src="index_files/figure-html/map-1.png" style="display: block; margin: auto;" /&gt;

---
Now, when the projections do not match:

```r
countries_p &lt;- spTransform(countries,
                              crs("+proj=laea  +lat_0=0 +lon_0=0"))
plot(countries_p, axes = T)
plot(pkmng_points, add = T, pch = 1, col = "red")
```

&lt;img src="index_files/figure-html/map 2-1.png" style="display: block; margin: auto;" /&gt;

---
Whereas matching projections give us all the coordinates in the right place:

```r
plot(countries_p, axes = T)
plot(pkmng_points_p, add = T, pch = 1, col = "red")
```

&lt;img src="index_files/figure-html/map 3-1.png" style="display: block; margin: auto;" /&gt;

---
# Extent

Spatial objects also have extents - these are the minimum and maximum X and Y coordinates of the object. They don't have to have data in them. The coordinates of course depend on your projection and units:


```r
countries@bbox
```

```
##    min       max
## x -180 180.00000
## y  -90  83.57027
```

```r
countries_p@bbox
```

```
##         min      max
## x -12726751 12733710
## y -12641498 12299760
```

---
For raster objects, you find the extent with this syntax:

```r
pkmng_raster@extent
```

```
## class      : Extent 
## xmin       : -180 
## xmax       : 180 
## ymin       : -86.42973 
## ymax       : 83.57027
```

---
You can change the extent of objects using the crop or extend functions, depending on whether you want to decrease or increase the extent:

```r
pkmng_raster_c &lt;- crop(pkmng_raster,
                      extent(-50,
                             100,
                             0,
                             80))
```

---

```r
plot(pkmng_raster)
plot(pkmng_raster_c, add = T, col = "red")
```

&lt;img src="index_files/figure-html/extent 4-1.png" style="display: block; margin: auto;" /&gt;

All the red cells are in the new, limited extent!

---
## Why is this important?

If you try to do spatial arithmetics on objects with mismatching extents and projections, you'll get errors. For example:

```r
raster::intersect(countries_p, pkmng_raster_c)
```

```
## Warning in intersect(x, y): non identical CRS
```

```
## Warning in intersect(x, y): polygons do not intersect
```

```
## NULL
```

---
class: center, middle
# Different GIS tools out there

.center[
.img-med[
![](pres_pictures/Screenshot 2019-05-21 20.53.18.png)
]]
---
class: center, middle
# Data manipulation

---
class: center, middle
# Georeferencing
Manipulating two vector data

---
### **Buffer points** - creating a polygon based on proximity
**For example:** buffer some of the pokemon points to 100km radious
We'll first subset the data to have less points

```r
sub_pkmng_p&lt;- subset(pkmng_points,pokemonId %in%c(8:10))
plot(countries)
plot(sub_pkmng_p,add = T, col = "red")
```

&lt;img src="index_files/figure-html/unnamed-chunk-2-1.png" style="display: block; margin: auto;" /&gt;
---
Now we'll buffer the points in a 100km radius to make them into polygons

```r
buffer_pkmng_points&lt;- raster::buffer(sub_pkmng_p,width = 100000)
plot(countries)
plot(buffer_pkmng_points,add = T, col = "red")
```

&lt;img src="index_files/figure-html/unnamed-chunk-3-1.png" style="display: block; margin: auto;" /&gt;

---
### **Clip** - an overlay function that cuts out an input layer with the extent of a defined feature boundary. The result of this tool is a new clipped output layer. 

There are a few ways of clipping polygons in R, we will look at using the rgdal package. The latter is more integrated with tidyverse
---
Lets clip the buffered points to to have the ones that fall in Italy and to fit the bounderies of the Italian coastline.

First, well filter the countries shapefile to have a shapefile of Italy

```r
Italy &lt;- countries %&gt;% 
  filter(NAME == "Italy")
plot(Italy)
plot(buffer_pkmng_points,add = T, col = "red")
```

&lt;img src="index_files/figure-html/unnamed-chunk-4-1.png" style="display: block; margin: auto;" /&gt;
---
# `rgeos` package example
Now, lets clip the the buffered points based on the Italian shapefile we created

```r
clip_pkmng_rgeos&lt;- rgeos::gIntersection(Italy, buffer_pkmng_points, byid = TRUE, drop_lower_td = TRUE)
plot(Italy)
plot(clip_pkmng_rgeos,add = T, col = "red")
```

&lt;img src="index_files/figure-html/unnamed-chunk-5-1.png" style="display: block; margin: auto;" /&gt;

---

### **Intersect** - similar to the clip tool because the extents of input features defines the output. The only exception is that it preserves attributes from all the data sets that overlap each other in the output 

Lets intersect the points with the country shapefile to find which points belong to which country

```r
intersect_pkmg&lt;- raster::intersect(pkmng_points,countries) 
```

---
### **Merge** - combines data sets that are the same data type

```r
#subset the countries
sub_count&lt;- countries %&gt;% filter(NAME==c("France","Italy"))
sub_count_sf&lt;- sf::st_as_sf(sub_count)
merge_count&lt;- sf::st_combine(sub_count_sf)
plot(merge_count)
```

&lt;img src="index_files/figure-html/unnamed-chunk-7-1.png" style="display: block; margin: auto;" /&gt;

---
### **Dissolve** - The Dissolve Tool unifies boundaries based on common attribute values

```r
diss_sub_count&lt;- rgeos::gUnaryUnion(sub_count)
plot(diss_sub_count)
```

&lt;img src="index_files/figure-html/unnamed-chunk-8-1.png" style="display: block; margin: auto;" /&gt;

---
# Zonal statistics
Vector-Raster analysis. Allows you to calculate statistics from raster data for each feature in the vector data

**For Example:** We want to calculate the temperature in each point that a pokemon was collected

---
Download and plot the mean anual temperature from the web using the getData function

```r
climate &lt;- raster::getData('worldclim', var='bio', res=10)
annual_prec&lt;- climate$bio12
plot(annual_prec)
```

&lt;img src="index_files/figure-html/unnamed-chunk-9-1.png" style="display: block; margin: auto;" /&gt;

---
Now lets calculate the mean temperature in each point


```r
poke_annual_prec&lt;- raster::extract(annual_prec, pkmng_points,fun = mean,na.rm=T,df=T)
head(poke_annual_prec)
```

```
##   ID bio12
## 1  1   663
## 2  2  1326
## 3  3  1095
## 4  4   585
## 5  5   792
## 6  6   492
```

---
The data has no identification of which point it belongs to. To have that we need to merge it with the points identifiers


```r
poke_annual_prec_final&lt;- cbind(pkmng_points@data$pokemonId,poke_annual_prec$bio12)
names(poke_annual_prec_final)&lt;- c("pokemonId","annual_prec")
head(poke_annual_prec_final)
```

```
##      [,1] [,2]
## [1,]   16  663
## [2,]   60 1326
## [3,]   19 1095
## [4,]   16  585
## [5,]   23  792
## [6,]  120  492
```


---
# Spatial autocorrelation
Spatial data are not independent - violating assumptions of statistical tests.

Spatial autocorrelation decreases with distance - but the distance depends on your data.

So how do we test for spatial autocorrelation and what can we do about it?

---
## Testing for spatial autocorrelation

We'll use the pgirmess package:

```r
pacman::p_load(pgirmess)

#first we'll take a small sample of the points data, because this test is very time-consuming
pkmng_points_dat_s &lt;- sample_frac(pkmng_points_dat, 0.05)
pgi.cor &lt;- correlog(coords = pkmng_points_dat_s[,c("longitude","latitude")], #longitude and latitude, in that order
                    z = pkmng_points_dat_s$temperature, #the variable we want to test for autocorrelation in
                    method = "Moran")
```

---
The X axis is distance, and the Y axis is our measure of autocorrelation. Values higher than 0 mean there is spatial autocorrelation in that distance class.

```r
plot(pgi.cor)
```

&lt;img src="index_files/figure-html/sp ac 2-1.png" style="display: block; margin: auto;" /&gt;

---
## Dealing with spatial autocorrelation
There are various methods to "eliminate" spatial autocorrelation for hypothesis testing and statiscal inference. All are flawed, each in their own way.

We won't talk about them here, but you can read more in the literature:
https://onlinelibrary.wiley.com/doi/10.1111/j.2007.0906-7590.05171.x
https://onlinelibrary.wiley.com/doi/10.1111/jbi.12953

---
# Spatial non-stationarity
Often, relationships between variables can shift in space. So global coefficients of models can be very poor at describing the actual behaviour of your data.

For example, let's look for a relationship between wind speed and temperature in our Pokemon Go sightings data:
.small[

```r
lm.model &lt;- lm(windSpeed ~
             temperature,
           data = pkmng_points_dat_s)
summary(lm.model)
```

```
## 
## Call:
## lm(formula = windSpeed ~ temperature, data = pkmng_points_dat_s)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
## -7.071 -3.112 -0.737  2.241 49.873 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  5.06517    0.40037  12.651  &lt; 2e-16 ***
## temperature  0.07405    0.01766   4.194 2.91e-05 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 4.249 on 1478 degrees of freedom
## Multiple R-squared:  0.01176,	Adjusted R-squared:  0.01109 
## F-statistic: 17.59 on 1 and 1478 DF,  p-value: 2.906e-05
```
]
---
Now, we'll map the residuals from this model:

```r
resids&lt;-residuals(lm.model)
colours &lt;- c("dark blue", "blue", "red", "dark red") 
map.resids &lt;- SpatialPointsDataFrame(data = data.frame(resids),
                                     coords = cbind(pkmng_points_dat_s$longitude,
                                                    pkmng_points_dat_s$latitude)
                                     ) 
```

---

```r
spplot(map.resids, cuts=quantile(resids), col.regions=colours, cex=1)
```

&lt;img src="index_files/figure-html/gwr 3-1.png" style="display: block; margin: auto;" /&gt;
Notice how the red and blue dots are clustered together, and not randomly distributed - showing a spatial pattern in the residuals.

---
We can use a method called GWR (Globally Weighted Regression) to account for this - basically, you calculate a regression coefficient for each datum, weighing the contribution of all data based on their spatial distance from your focal datum.

.small[

```r
pacman::p_load(spgwr)
GWRbandwidth &lt;- gwr.sel(windSpeed ~
                          temperature,
                        data = pkmng_points_dat_s,
                        coords = cbind(pkmng_points_dat_s$longitude,
                                                    pkmng_points_dat_s$latitude),
                        adapt = T)
```

```
## Adaptive q: 0.381966 CV score: 25971.6 
## Adaptive q: 0.618034 CV score: 26470.16 
## Adaptive q: 0.236068 CV score: 25779.09 
## Adaptive q: 0.145898 CV score: 25429.72 
## Adaptive q: 0.09016994 CV score: 24672.23 
## Adaptive q: 0.05572809 CV score: 23923.28 
## Adaptive q: 0.03444185 CV score: 22690.01 
## Adaptive q: 0.02128624 CV score: 21834.46 
## Adaptive q: 0.01315562 CV score: 20909.26 
## Adaptive q: 0.008130619 CV score: 20374.53 
## Adaptive q: 0.005024999 CV score: 21990.94 
## Adaptive q: 0.01005 CV score: 20553.34 
## Adaptive q: 0.006944377 CV score: 21538.02 
## Adaptive q: 0.008863756 CV score: 20508.88 
## Adaptive q: 0.007677515 CV score: 20717.15 
## Adaptive q: 0.008410652 CV score: 20342.56 
## Adaptive q: 0.008357601 CV score: 20328.39 
## Adaptive q: 0.008304636 CV score: 20328.57 
## Adaptive q: 0.008357601 CV score: 20328.39
```
]
---

```r
gwr.model &lt;- gwr(windSpeed ~
                   temperature,
                 data = pkmng_points_dat_s,
                 coords = cbind(pkmng_points_dat_s$longitude,
                                pkmng_points_dat_s$latitude),
                 adapt = GWRbandwidth,
                 hatmatrix = T,
                 se.fit = T
                 )
gwr.results &lt;- as_tibble(gwr.model$SDF)
```

---
Now we can view the table of the results, and see the coefficient for each datum in our dataset - i.e. for each point locality. We can see they vary quite a bit.
.small[

```r
gwr.results
```

```
## # A tibble: 1,480 x 14
##    sum.w X.Intercept. temperature X.Intercept._se temperature_se
##    &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;           &lt;dbl&gt;          &lt;dbl&gt;
##  1  30.7        31.2      -1.02              3.18         0.131 
##  2  13.8         6.22     -0.105             6.27         0.257 
##  3  14.4        11.4      -0.0643            7.80         0.390 
##  4  13.2         2.73      0.317             3.33         0.246 
##  5  63.8         5.35      0.0547            1.15         0.0454
##  6  45.0         6.98      0.0553            1.41         0.0763
##  7  20.7        10.4      -0.201             2.64         0.135 
##  8  13.9         1.26      0.365             3.11         0.182 
##  9  14.4        11.4      -0.0654            7.78         0.389 
## 10  13.1        -9.07      0.666             3.64         0.158 
## # ... with 1,470 more rows, and 9 more variables: gwr.e &lt;dbl&gt;,
## #   pred &lt;dbl&gt;, pred.se &lt;dbl&gt;, localR2 &lt;dbl&gt;,
## #   X.Intercept._se_EDF &lt;dbl&gt;, temperature_se_EDF &lt;dbl&gt;,
## #   pred.se.1 &lt;dbl&gt;, coord.x &lt;dbl&gt;, coord.y &lt;dbl&gt;
```
]
---
Now let's plot this and see exactly what this non-stationarity looks like:
.small[

```r
pkmng_points_dat_s$coef &lt;- gwr.results$temperature
countries_outline &lt;- fortify(countries,
                             region = "NAME")

mapWorld &lt;- borders("world", colour=NA, fill="gray")
```

```
## Warning: package 'maps' was built under R version 3.5.2
```

```r
gwr.map &lt;- ggplot(data = pkmng_points_dat_s,
                  aes(x = longitude,
                      y = latitude,
                      colour = coef)
                  ) + 
  mapWorld +
  geom_point() + 
  scale_colour_gradient2(low = "red",
                         mid = "white",
                         high = "blue",
                         midpoint = 0,
                         space = "rgb",
                         na.value = "grey50",
                         guide = "colourbar",
                         guide_legend(title="Coefs")) +
  coord_equal()
```

```
## Warning: Non Lab interpolation is deprecated
```
]
---
And see how the regression coefficients change with space - blue for positive coefficients and red for negative ones:


```r
gwr.map
```

&lt;img src="index_files/figure-html/gwr 8-1.png" style="display: block; margin: auto;" /&gt;

---
# TAKE HOME MESSAGES

* Be mindful of projections!
* Be mindful of spatial autocorrelation!
* Visualize spatial patterns!
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://platform.twitter.com/widgets.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
